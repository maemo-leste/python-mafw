/* -*- Mode: C; c-basic-offset: 4 -*-
 * python-mafw - Python bindings for the MAFW library.
 *
 *   mafw.override: overrides for the mafw module.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA
 */
%%
headers
#define NO_IMPORT_PYGOBJECT
#include <pygobject.h>
#include <Python.h>

#include "mafw-includes.h"
#include "mafw-types.h"

%%
modulename mafw

%%
import gobject.GObject as PyGObject_Type
import gobject.GObject as PyGInitiallyUnowned_Type

%%
ignore-glob *_get_type

%%
override mafw_playlist_manager_get noargs staticmethod
static PyObject *
_wrap_mafw_playlist_manager_get(PyGObject *self)
{
    MafwPlaylistManager *manager;

    manager = mafw_playlist_manager_get();

    return pygobject_new((GObject *)manager);
}

%%
override mafw_registry_get_instance noargs staticmethod
static PyObject *
_wrap_mafw_registry_get_instance(PyGObject *self)
{
    MafwRegistry *registry = NULL;

    registry = mafw_registry_get_instance();

    return pygobject_new((GObject *)registry);
}

%%
override mafw_playlist_manager_get_playlists noargs
static PyObject *
_wrap_mafw_playlist_manager_get_playlists(PyGObject *self)
{
    GPtrArray *list = NULL;
    PyObject *py_list;
    GError *errp = NULL;
    gint i;

    list = mafw_playlist_manager_get_playlists(MAFW_PLAYLIST_MANAGER(self->obj), &errp);

    if (pyg_error_check(&errp))
        return NULL;

    if (list == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "could not get playlists");
        return NULL;
    }

    if ((py_list = PyList_New(list->len)) == NULL)
        return NULL;

    for (i = 0; i < list->len; i++) {
        MafwPlaylist *pl = (MafwPlaylist *)g_ptr_array_index (list, i);
        PyObject *item = pygobject_new((GObject *)pl);
        PyList_SetItem(py_list, i, item);
    }
    /* FIXME: currently leaks memory for the GPtrArray. */

    return py_list;
}

%%
override mafw_registry_get_renderers noargs
static PyObject *
_wrap_mafw_registry_get_renderers(PyGObject *self)
{
    GList *wlist;
    guint nwlist;
    int i;
    PyObject *list;

    wlist = mafw_registry_get_renderers(MAFW_REGISTRY(self->obj));
    nwlist = g_list_length(wlist);

    if ((list = PyList_New(nwlist)) == NULL)
        return NULL;

    for (i = 0; i < nwlist; i++) {
        PyObject *item = pygobject_new((GObject *)g_list_nth_data(wlist, i));
        PyList_SetItem(list, i, item);
    }

    return list;
}

%%
override mafw_registry_add_extension kwargs
static PyObject *
_wrap_mafw_registry_add_extension(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "extension", NULL };
    PyGObject *extension;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!:MafwRegistry.add_extension",
                                     kwlist, &PyMafwExtension_Type, &extension))
        return NULL;

    mafw_registry_add_extension(MAFW_REGISTRY(self->obj), MAFW_EXTENSION(extension->obj));

    Py_INCREF(Py_None);
    return Py_None;
}

%%
override mafw_registry_get_sources noargs
static PyObject *
_wrap_mafw_registry_get_sources(PyGObject *self)
{
    GList *wlist;
    guint nwlist;
    int i;
    PyObject *list;

    wlist = mafw_registry_get_sources(MAFW_REGISTRY(self->obj));
    nwlist = g_list_length(wlist);

    if ((list = PyList_New(nwlist)) == NULL)
        return NULL;

    for (i = 0; i < nwlist; i++) {
        PyObject *item = pygobject_new((GObject *)g_list_nth_data(wlist, i));
        PyList_SetItem(list, i, item);
    }

    return list;
}

%%
override mafw_registry_list_plugins noargs
static PyObject *
_wrap_mafw_registry_list_plugins(PyGObject *self)
{
    GList *wlist = NULL;
    guint nwlist;
    int i;
    PyObject *list = NULL;

    wlist = mafw_registry_list_plugins(MAFW_REGISTRY(self->obj));

    nwlist = g_list_length(wlist);

    if ((list = PyList_New(nwlist)) == NULL)
        return NULL;

    for (i = 0; i < nwlist; i++) {
        PyObject *pyitem = NULL;
        PyObject *attr = NULL;

        MafwPluginDescriptorPublic *item = (MafwPluginDescriptorPublic*)g_list_nth_data(wlist, i);
        if (!item) {
            PyErr_SetString(PyExc_RuntimeError, "Invalid plugin descriptor found");
            if (wlist)
                g_list_free(wlist);
            return NULL;
        }

        pyitem = PyTuple_New(3);

        if (item->name) {
            attr = PyString_FromString(item->name);
        } else{
            attr = Py_None;
            Py_INCREF(attr);
        }
        PyTuple_SetItem(pyitem, 0, attr);

        if (item->description) {
            attr = PyString_FromString(item->description);
        } else{
            attr = Py_None;
            Py_INCREF(attr);
        }
        PyTuple_SetItem(pyitem, 1, attr);


        if (item->version) {
            attr = PyString_FromString(item->version);
        } else{
            attr = Py_None;
            Py_INCREF(attr);
        }
        PyTuple_SetItem(pyitem, 2, attr);

        PyList_SetItem(list, i, pyitem);
    }
    if (wlist) {
        g_list_free(wlist);
    }

    return list;
}

%%
override mafw_source_browse varargs
static PyObject *
_wrap_mafw_source_browse(PyObject *self, PyObject *args, PyObject *kwds)
{
    char *object_id;
    int recursive;
    char *filter;
    char *sort_criteria;
    char *metadata_keys;
    int skip_count;
    int item_count;
    PyObject *browse_cb;
    gpointer user_data = NULL;

    int browse_id = 0;

    if (!PyArg_ParseTuple(args, "ssO", &object_id, &metadata_keys, &browse_cb))
        return NULL;

    g_print("DEBUG::object_id: %s \n", object_id);
    g_print("DEBUG::metadata_keys: %s \n", metadata_keys);

    browse_id = mafw_source_browse(self,            /* Source */
                                   object_id,       /* Object identifier */
                                   FALSE,           /* Recursive */
                                   NULL,            /* Filter */
                                   NULL,            /* Sorting */
                                   metadata_keys,   /* Requested keys */
                                   0, 30,            /* Offset, Count*/
                                   browse_cb,        /* Callback */
                                   NULL);            /* User data */

    return Py_BuildValue("i", browse_id);
}

%%
define METADATA_KEY_CHILDCOUNT
static PyObject *
_wrap_METADATA_KEY_CHILDCOUNT(PyGObject *self, PyObject *args)
{
    int n;

    if (!PyArg_ParseTuple(args, "i", &n))
        return NULL;

    return Py_BuildValue("s", MAFW_METADATA_KEY_CHILDCOUNT(n));
}

%%
override mafw_source_get_update_progress noargs
static PyObject *
_wrap_mafw_source_get_update_progress(PyGObject *self)
{
    PyObject *results;
    int ret, processed, remaining_items, remaining_time;

    ret = mafw_source_get_update_progress( MAFW_SOURCE(self->obj), &processed,
                                          &remaining_items,
                                          &remaining_time);

    results = PyTuple_New(4);

    PyTuple_SetItem(results, 0, PyInt_FromLong(ret));
    PyTuple_SetItem(results, 1, PyInt_FromLong(processed));
    PyTuple_SetItem(results, 2, PyInt_FromLong(remaining_items));
    PyTuple_SetItem(results, 3, PyInt_FromLong(remaining_time));

    return results;
}
